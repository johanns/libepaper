#pragma once

/**
 * @file spi.hpp
 * @brief SPI bus concept for hardware abstraction.
 *
 * Defines C++20 concept for SPI data transfer operations, enabling
 * generic driver code that works with any SPI backend.
 *
 * **Design Philosophy:**
 * ```
 * Hardware Abstraction via Concepts
 * ├─ Platform Independence: Drivers work with Linux SPIdev, embedded HALs, mocks
 * ├─ Minimal Interface: Only data transfer, no config (CS/DC handled by GPIO)
 * ├─ Zero Overhead: Concepts inline to register-level ops in production
 * └─ Mockability: Easy to substitute mock SPI for testing
 * ```
 *
 * **SPI Responsibilities:**
 * - **MOSI**: Master Out, Slave In (data from CPU to display)
 * - **MISO**: Master In, Slave Out (data from display to CPU) [full-duplex only]
 * - **SCLK**: Serial clock (generated by master)
 *
 * **NOT Handled by SpiBus:**
 * - **Chip Select (CS)**: Managed by GPIO DigitalOutput pin
 * - **Data/Command (DC)**: Managed by GPIO DigitalOutput pin
 * - **Configuration**: Mode, speed, bit order set externally (e.g., Device constructor)
 *
 * **Rationale for Minimal Interface:**
 * E-paper displays require precise CS/DC control for command vs data writes.
 * Decoupling CS/DC from SPI allows drivers to implement hardware-specific
 * timing requirements (e.g., CS must go low 10ns before SCLK starts).
 *
 * **Typical Implementations:**
 * - **Production**: Linux SPIdev wrapper (ioctl-based, /dev/spidevX.Y)
 * - **Testing**: MockSPI (records writes, simulates reads)
 * - **Embedded**: Platform-specific SPI peripheral drivers
 *
 * **Thread Safety:**
 * - SpiBus concept does not require thread-safe operations
 * - Concurrent access must be synchronized externally (e.g., mutex in Device)
 *
 * @example
 * ```cpp
 * // Using concept-constrained SPI transfer
 * template <hal::SpiBus Spi>
 * void send_command(Spi& spi, std::uint8_t cmd) {
 *   spi.transfer(cmd);  // Full-duplex transfer (ignore returned byte)
 * }
 *
 * template <hal::SpiBus Spi>
 * void send_data(Spi& spi, std::span<const std::byte> data) {
 *   spi.write(data);  // Bulk write (more efficient than individual transfers)
 * }
 * ```
 *
 * @see MockSPI, Device (uses SpiBus concept)
 */

#include <concepts>
#include <cstdint>
#include <span>

namespace epaper::hal {

/**
 * @brief Concept for a raw SPI data transfer bus.
 *
 * Provides full-duplex byte transfer and bulk write capabilities.
 * **Does NOT handle Chip Select (CS) or Data/Command (DC) signals** - these
 * are managed externally via GPIO pins.
 *
 * **Required Operations:**
 * 1. `transfer(byte)`: Full-duplex single-byte exchange (write + simultaneous read)
 * 2. `write(data)`: Bulk write (transmit-only, ignore received data)
 *
 * **Method Signatures:**
 * ```cpp
 * auto transfer(std::uint8_t byte) -> std::uint8_t;
 * auto write(std::span<const std::byte> data) -> void;
 * ```
 *
 * **Semantic Requirements:**
 * - `transfer(byte)`: Transmits `byte` on MOSI, returns value received on MISO
 *   - Blocking until transfer complete (typically microseconds)
 *   - Clock polarity/phase determined by SPI mode (configured externally)
 * - `write(data)`: Transmits all bytes in `data` sequentially
 *   - More efficient than N calls to `transfer()` (avoids per-byte overhead)
 *   - Received data discarded (MISO ignored)
 *   - Blocking until all bytes transmitted
 *
 * **SPI Mode Configuration (not part of concept):**
 * - Mode 0 (CPOL=0, CPHA=0): Clock idle LOW, sample on rising edge
 * - Mode 1 (CPOL=0, CPHA=1): Clock idle LOW, sample on falling edge
 * - Mode 2 (CPOL=1, CPHA=0): Clock idle HIGH, sample on falling edge
 * - Mode 3 (CPOL=1, CPHA=1): Clock idle HIGH, sample on rising edge
 * E-paper displays typically use Mode 0.
 *
 * **Chip Select (CS) Protocol:**
 * ```cpp
 * cs.write(false);       // Assert CS (active-low)
 * spi.write(data);       // Transfer data
 * cs.write(true);        // Deassert CS
 * ```
 *
 * **Data/Command (DC) Protocol:**
 * ```cpp
 * dc.write(false);       // DC=0 for command
 * cs.write(false);
 * spi.transfer(0x2C);    // Send command byte
 * cs.write(true);
 *
 * dc.write(true);        // DC=1 for data
 * cs.write(false);
 * spi.write(framebuffer);
 * cs.write(true);
 * ```
 *
 * @tparam T Type to check for SpiBus conformance
 *
 * @see DigitalOutput (for CS/DC control), MockSPI
 */
template <typename T>
concept SpiBus = requires(T bus, std::uint8_t byte, std::span<const std::byte> data) {
  { bus.transfer(byte) } -> std::same_as<std::uint8_t>;
  { bus.write(data) } -> std::same_as<void>;
};

} // namespace epaper::hal
